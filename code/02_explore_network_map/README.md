## [English translation](https://github.com/natenka/q_and_a/blob/main/code/02_explore_network_map/README_ENG.md)

## Обнаружение топологии сети по CDP/LLDP

Надо обнаружить топологию сети через вывод CDP (считаем что CDP есть на всех устройствах).
Для старта должен быть известен один IP-адрес устройства и параметры подключения
по SSH ко всем устройствам в сети.

> Можно использовать CDP или LLDP.

Надо подключиться к первому устройству, дать команду ``sh cdp neighbors detail``, получить
всех соседей и их IP-адреса и подключаться к каждому соседу.
На каждом соседе опять дать команду ``sh cdp neighbors detail`` и получить соседей этого устройства.
Так надо пройтись по всей сети и собрать информацию об устройствах и топологии.


Например, если топология такая и известен IP-адрес R1:

```
.====.    .=====.    .====.
| R1 |----| SW1 |----| R2 |  
'===='    '====='    '===='
             |
             |
          .====.
          | R3 |
          '===='
```

Порядок работы может быть примерно такой:

1. Подключаемся к R1 и получаем соседей CDP - только SW1
2. Подключаемся к SW1 и получаем три соседа R1, R2, R3 - подключаемся только к R2 и R3, так как на R1 уже были

IP-адреса устройств в словаре ниже:

* R1 192.168.100.1
* R2 192.168.100.2
* R3 192.168.100.3
* SW1 192.168.100.100

Итоговая топология может выглядеть как угодно, как вариант это может быть такой словарь:

```python
{'192.168.100.1': {'192.168.100.100': {'local_port': 'Ethernet0/0',
                                       'remote_port': 'Ethernet0/1'}},
 '192.168.100.100': {'192.168.100.1': {'local_port': 'Ethernet0/1',
                                       'remote_port': 'Ethernet0/0'},
                     '192.168.100.2': {'local_port': 'Ethernet0/2',
                                       'remote_port': 'Ethernet0/0'},
                     '192.168.100.3': {'local_port': 'Ethernet0/3',
                                       'remote_port': 'Ethernet0/0'}},
 '192.168.100.2': {'192.168.100.100': {'local_port': 'Ethernet0/0',
                                       'remote_port': 'Ethernet0/2'}},
 '192.168.100.3': {'192.168.100.100': {'local_port': 'Ethernet0/0',
                                       'remote_port': 'Ethernet0/3'}}}
```

Я выбрала именно такой формат потому что мне было удобно с ним работать,
но сам итоговый формат описания топологии не принципиален, главное как-то
отмечать как оборудование связано между собой.

## Петли в топологии

Следующий шаг: проверить, что код работает и для топологии в которой есть петли.

```
.====.    .=====.    .====.
| R1 |----| SW1 |----| R2 |  
'===='    '====='    '===='
             |         |
             |         |
          .====.       |
          | R3 |-------|
          '===='
```

## Hostname

Если в предыдущих вариантах посещенный сосед отмечался по IP-адресу, надо
сделать так чтобы он отмечался и по hostname тоже, так как, например, SW1 и R2 будут
видеть R3 через разные IP-адреса и R3 будет считаться непосещенным соседом.


Пример итоговых данных с hostname:

```python
{'R1': {'SW1': {'ip': '192.168.100.100',
                'local_port': 'Ethernet0/0',
                'remote_port': 'Ethernet0/1'}},
 'R2': {'R3': {'ip': '10.100.23.3',
               'local_port': 'Ethernet0/1',
               'remote_port': 'Ethernet0/1'},
        'SW1': {'ip': '192.168.100.100',
                'local_port': 'Ethernet0/0',
                'remote_port': 'Ethernet0/2'}},
 'R3': {'R2': {'ip': '10.100.23.2',
               'local_port': 'Ethernet0/1',
               'remote_port': 'Ethernet0/1'},
        'SW1': {'ip': '192.168.100.100',
                'local_port': 'Ethernet0/0',
                'remote_port': 'Ethernet0/3'}},
 'SW1': {'R1': {'ip': '192.168.100.1',
                'local_port': 'Ethernet0/1',
                'remote_port': 'Ethernet0/0'},
         'R2': {'ip': '192.168.100.2',
                'local_port': 'Ethernet0/2',
                'remote_port': 'Ethernet0/0'},
         'R3': {'ip': '192.168.100.3',
                'local_port': 'Ethernet0/3',
                'remote_port': 'Ethernet0/0'}}}
```

## Решение

* solution_1_ip_only.py - вариант решения с учетом только IP-адресов при определении было ли устройство посещено
* solution_2_ip_and_hostname.py - вариант решения с учетом IP-адресов и hostname при определении было ли устройство посещено
* solution_3_ip_and_hostname_rich_live.py - второй вариант, но с выводом топологии с помощью Rich

